Code Execution: Language to execution
--------------------------------------
[install gcc, and clang to try out the commands]

High level languages go through few steps before execution of the instructions.
It can be roughly divided into these steps:

1. Preprocessing.
2. Compilation.
3. Linking.
4. Loading.
5. Executing.

Compilation includes few other steps within it. Technically it ends with the generation of machine code. The steps in compilation are:
1. Lexical analysis
2. Parsing.
3. Semantic analysis.
4. Intermediate code generation
5. Optimization of intermediate code
6. Assembly code generation
7. Machine code(Object code)


Preprocessing:
--------------
In preprocessing step, the compiler-
  - Includes all the contents of the files included using the #include preprocessor directive at the exact place it was added to.
  - To prevent infinite loop of including the same files, there are header guards like #ifndef HEADER_H, #define HEADER_H, and #endif.
  also a more modern approach to use #pragma once.
  - Expands(replaces every instance of a macro with it's value) the macros defined using the #define preprocessor directive.
  - Removes the comments and replaces them by an empty character in order to avoid accidental token merging.
  - Adds linemarkers and metadata to understand where the original code came from.
  - Replaces trigraph and digraph

Command to see preprocessed file using gcc compiler: gcc -E main.c

Lexical Analysis:
-----------------
The source code gets scanned by the compiler and broken into tokens. These tokens are the smallest units of a program
Such as: Keywords, identifiers, operators, and punctuation. Lexical analyzer also known as scanner does this.
It breaks the code into tokens like:
using, namespace, std

int, main, (,), {,}
int, a, b,;
a,=,9,b,=,2;
cout,<<,a,<<b,;
reutrn,0,;

These tokens get passed to the next phase as a stream.

Command to see tokenized file using clang compiler: clang -Xclang -dump-tokens main.c


Parsing:
--------
The parser takes the stream of tokens generated by the scanner/lexical analyzer and then checks the syntax
of the code to check if it follows the rules of the programming language. It organizes the tokens in a
tree like structure called Abstract Syntax Tree(AST) or parse tree.
It checks the grammar, doesn't check for the meaning or logic of the language.
For example the grammar to declare and initialize a variable might be like:
[type] [identifier] [assignment-operator] [value] [semicolon]

Command to see the AST: clang -Xclang -ast-dump -fsyntax-only main.cpp

Semantic analysis:
------------------
Semantic analyzer takes the AST generated by the parser and checks for semantics following the rules of the language.
It checks:
  - Types
  - Scopes
  - Function operations(return type and all)
  etc.

After that it creates an "Annotated" or "Decorated" syntax tree also known as AST(annotated syntax tree).
This has additional information about scope, resolved references and all. It basically makes sure that the program
actually makes sense

Command to see AST(annotated syntax tree): clang -Xclang -ast-dump -fsyntax-only main.cpp


IR(Intermediate code generation/representaion):
-----------------------------------------------
In this step the compiler translates the Annotated syntax tree to an Intermediate representation(IR).
This IR is a simplified, low-level, platform independent code that is easier to optimize and translate to machine code.
TAC(three-address code) is an intermediate representation where each instruction has at most three operands.
The IR varies by compiler. Some use three-address code, while others use representations like LLVM IR or abstract syntax trees.

Command to see IR: clang -S -emit-llvm main.cpp -o source_unopt.ll.

Optmization:
------------
In this step the compiler optmizes the IR to make it more efficient(faster execution, less memorize, reducing size of the maching code)

Optmization:
------------
In this step the compiler optmizes the IR to make it more efficient(faster execution, less memorize, reducing size of the maching code).
This step computes constant expressions at compile time, removes unreachable or unused code, and eliminates repeated computations of the same value.
It also replaces expensive operations with cheaper ones.


Command to see the optmized IR: clang -O2 -S -emit-llvm source.cpp -o source.ll


Assembly Code Generation:
-------------------------
The compiler translates the optimized IR into low-level assembly code that is specific to the target machine architecture.

Command to see the assembly code: clang -S source.cpp -o source.s


Machine Code:
-------------
The final output of the compilation process. Machine code is composed of binary instructions that are directly executable
by the computer's CPU. Machine code is typically stored in .o or .obj  files which contains the compiled binary representation.

Command to see the machine code: gcc main.c -o main


Linking:
--------
After compiling and generating object files(machine code files) a special program called linker combines all these object files.
This creates the final executable program.
If a program uses external libraries, linker resolves those references and links those to the program.
By default the linker generates the executable with the name a.out if no name is specified for the output file.

Command to generate default output: gcc filename.c

Loading:
-------
The loader loads the executable in to the system's memory(generally RAM) to prepare it for execution.
The loader does few things:
  - Loads the executable in appropriate memory location.
  - Resolves addresses for the functions, variables, objects etc.
  - Sets up stack, heap, and other memory regions needed for execution.
  - Loads any dynamic libraries or shared objects that the program depends on. 


Execution:
---------
Finally once the program is loaded in the memory, the OS hands over the control to the program's entry point
and start executing instructions in sequence.

CPU handles the execution in these steps:
  - The IP(Instruction Pointer): This is like a bookmark that stores the address of an instruction in the executable.
  - Fetching: CPU fetches the instruction from the address in IP.
  - Decoding: CPU's control unit decodes the meaning of the instruction.
  - Executing: CPU's ALU(Arithmetic Logic Unit) does the math and data move.
  - Repeat: Then the IP moves to the next instruction in the RAM and the cycle repeats.
